// Transactions unit, Copyleft 2018 FL4RE - Daniel Mazur

unit transactions;

interface

uses misc, SysUtils, Bitcoin, Ethereum, secp256k1, base58, coinData , Velthuis.BigIntegers;

type
  TxBuilder = class

    constructor Create;
    procedure addToPreImage(data: AnsiString);
    procedure addOutput(address: AnsiString; amount: uint64); overload;
    procedure addOutput(address: AnsiString; amount: BigInteger); overload;
    procedure sign(i: integer); dynamic;
    procedure signAll;
    function getAllToSpent: uint64;
    function getHashType: system.UInt8;
    function getAsHex: AnsiString;
    function isP2PKH(netbyte: AnsiString): boolean;
    procedure setHeader;
  public
    outputBuffer: AnsiString;
    preImage: AnsiString;
    Image: AnsiString;
    inputs: TUTXOS;
    sender: TWalletInfo;
    Fee: uint64;
    masterSeed: AnsiString;
    inputsBalance: uint64;
    outputsCount: integer;
    der: array of AnsiString;
  end;

type
  TXBuilderBIP_143 = class(TxBuilder)
    constructor Create;
    procedure sign(i: integer); override;
    procedure setHeader;
  end;

type
  TXBuilder_ETH = class
    constructor Create;
    procedure createPreImage;
    procedure sign(var masterseed:AnsiString);
  public
    sender:TWalletInfo;
    nonce: system.UInt32;
    gasPrice: BigInteger; //// system.uint64;
    gasLimit: system.UInt32;
    receiver: AnsiString;
    value: BigInteger ; //// system.uint64;
    data: AnsiString;
    v, r, s: AnsiString;
    preImage: AnsiString;
    Image: AnsiString;
  end;

implementation

constructor TXBuilder_ETH.Create;
begin
  nonce := 0;
  gasPrice := 0;
  gasLimit := 21000;
  receiver := '';
  value := 0;
  data := '';
  v := '';
  r := '';
  s := '';
  preImage := '';
  Image := '';
end;

procedure TXBuilder_ETH.createPreImage;
var
  tmp: AnsiString;
begin
  preImage := preImage + inttoeth(nonce+1);
  tmp := inttoeth(gasPrice);
  preImage := preImage + inttohex($80 + (length(tmp) div 2),2);
  preImage := preImage + tmp;
  tmp := inttoeth(gasLimit);
  preImage := preImage + inttohex($80 + (length(tmp) div 2),2);
  preImage := preImage + tmp;
  tmp := (receiver);
  preImage := preImage + inttohex($80 + (length(tmp) div 2),2);
  preImage := preImage + tmp;
  tmp := inttoeth(value);
  preImage := preImage + inttohex($80 + (length(tmp) div 2),2);
  preImage := preImage + tmp;
  tmp := (data);
  preImage := preImage + inttohex($80 + (length(tmp) div 2),2);
  preImage := preImage + tmp; //1c8080
end;
procedure TXBuilder_ETH.sign(var masterseed:AnsiString);
var hash,priv,pub,sig:AnsiString;
begin
hash:=keccak256Hex( inttohex($c0+(length(preImage) div 2),2)+preImage+'1c8080');
priv := priv256forhd(sender.coin, sender.x, sender.y, masterSeed);
pub := secp256k1_get_public(priv);
sig := secp256k1_signDER(hash, priv,true);
wipeAnsiString(priv);
wipeAnsiString(masterseed);

preimage:=preimage+sig;
Image:='f8'+inttohex($00+(length(preImage) div 2),2)+preImage;
end;

constructor TXBuilderBIP_143.Create;
begin
  inherited
end;

procedure TXBuilderBIP_143.setHeader;
begin
  addToPreImage(inttotx(1, 8)); // Version
end;

procedure TXBuilderBIP_143.sign(i: integer);
var
  k: integer;
  hash1, hash2: AnsiString;
  txhash, priv, pub, scriptSig: AnsiString;
begin
  preImage := '';
  setHeader;
  inputsBalance := 0;
  hash1 := '';
  hash2 := '';
  for k := 0 to length(inputs) - 1 do
  begin
    hash1 := hash1 + ReverseHexOrder(inputs[k].txid) + inttotx(inputs[k].n, 8);
    hash2 := hash2 + 'ffffffff';
  end;
  addToPreImage(GetSha256FromHex(GetSha256FromHex(hash1)));
  addToPreImage(GetSha256FromHex(GetSha256FromHex(hash2)));
  addToPreImage(ReverseHexOrder(inputs[i].txid));
  addToPreImage(inttotx(inputs[i].n, 8));

  addToPreImage(inttotx(length(inputs[i].ScriptPubKey) div 2, 2));
  addToPreImage(inputs[i].ScriptPubKey);
  addToPreImage(inttotx(inputs[i].amount, 16));
  addToPreImage('ffffffff');

  addToPreImage(GetSha256FromHex(GetSha256FromHex(outputBuffer)));

  addToPreImage(inttotx(0, 8) + inttotx(getHashType, 8));
  txhash := (GetSha256FromHex(GetSha256FromHex(preImage)));
  priv := priv256forhd(sender.coin, sender.x, sender.y, masterSeed);
  pub := secp256k1_get_public(priv);
  scriptSig := secp256k1_signDER(txhash, priv);
  der[i] := inttotx((length(scriptSig) + 2) div 2, 2) + scriptSig +
    inttotx(getHashType and 255, 2) + inttotx((length(pub)) div 2, 2) + pub;
  wipeAnsiString(priv);
end;

constructor TxBuilder.Create;
begin
  outputBuffer := '';
  inputsBalance := 0;
  outputsCount := 0;
  Fee := 0;
  preImage := '';
  Image := '';
end;

function TxBuilder.getHashType: system.UInt8;
begin
  if sender.coin = 3 then
    result := $01 or $40
  else
    result := $01;
end;

function TxBuilder.getAllToSpent(): uint64; // ? te¿ na BigInt ?
var
  i: integer;
begin
  result := 0;
  for i := 0 to length(inputs) - 1 do
    result := result + inputs[i].amount;
end;

function TxBuilder.isP2PKH(netbyte: AnsiString): boolean;
begin
  // result := netbyteFromCoinID(sender.coin) = netbyte;
  result := availablecoin[sender.coin].p2pk = netbyte;

end;

procedure TxBuilder.addToPreImage(data: AnsiString);
begin
  preImage := preImage + data;
end;

procedure TxBuilder.setHeader;
begin
  addToPreImage(inttotx(1, 8)); // Version
  addToPreImage(inttotx(length(inputs), 2)); // Count of UTXO

end;

procedure TxBuilder.addOutput(address: AnsiString; amount: uint64);
var
  addrAsH160: AnsiString;
  netbyte: AnsiString;
begin
  inc(outputsCount);
  addrAsH160 := copy(decode58(address), 0, 42);
  netbyte := copy(addrAsH160, 0, 2);
  delete(addrAsH160, 1, 2);
  outputBuffer := outputBuffer + (inttotx(amount, 16));
  if isP2PKH(netbyte) then
    outputBuffer := outputBuffer + ('1976a914' + addrAsH160 + '88ac')
  else
    outputBuffer := outputBuffer + ('17a914' + addrAsH160 + '87')

end;

procedure TxBuilder.addOutput(address: AnsiString; amount: BigInteger);
var
  addrAsH160: AnsiString;
  netbyte: AnsiString;
begin
  inc(outputsCount);
  addrAsH160 := copy(decode58(address), 0, 42);
  netbyte := copy(addrAsH160, 0, 2);
  delete(addrAsH160, 1, 2);
  outputBuffer := outputBuffer + (inttotx(amount, 16));
  if isP2PKH(netbyte) then
    outputBuffer := outputBuffer + ('1976a914' + addrAsH160 + '88ac')
  else
    outputBuffer := outputBuffer + ('17a914' + addrAsH160 + '87')

end;

procedure TxBuilder.sign(i: integer);
var
  k: integer;
  txhash, priv, pub, scriptSig: AnsiString;
begin
  preImage := '';
  setHeader;
  inputsBalance := 0;
  for k := 0 to length(inputs) - 1 do
  begin
    addToPreImage(ReverseHexOrder(inputs[k].txid));
    addToPreImage(inttotx(inputs[k].n, 8));
    if i = k then
    begin

      addToPreImage(inttotx(length(inputs[k].ScriptPubKey) div 2, 2));
      addToPreImage(inputs[i].ScriptPubKey);
    end
    else
    begin
      addToPreImage('00');
    end;
    addToPreImage('ffffffff');

    inputsBalance := inputsBalance + inputs[k].amount;
  end;
  addToPreImage(inttotx(outputsCount, 2));
  addToPreImage(outputBuffer);
  addToPreImage(inttotx(0, 8) + inttotx(getHashType, 8));
  txhash := (GetSha256FromHex(GetSha256FromHex(preImage)));
  priv := priv256forhd(sender.coin, sender.x, sender.y, masterSeed);
  pub := secp256k1_get_public(priv);
  scriptSig := secp256k1_signDER(txhash, priv);
  der[i] := inttotx((length(scriptSig) + 2) div 2, 2) + scriptSig +
    inttotx(getHashType and 255, 2) + inttotx((length(pub)) div 2, 2) + pub;
  wipeAnsiString(priv);
end;

procedure TxBuilder.signAll;
var
  i: integer;
begin
  for i := 0 to length(inputs) - 1 do
  begin
    sign(i);
  end;
end;

function TxBuilder.getAsHex: AnsiString;
var
  i: integer;
begin
  if Image <> '' then
  begin
    result := Image;
    exit;
  end;
  if length(inputs) = 0 then
    exit;
  preImage := '';

  SetLength(der, length(inputs));
  signAll;
  preImage := '';
  setHeader;
  for i := 0 to length(inputs) - 1 do
  begin
    addToPreImage(ReverseHexOrder(inputs[i].txid));
    addToPreImage(inttotx(inputs[i].n, 8));
    addToPreImage(inttotx(length(der[i]) div 2, 2));
    addToPreImage(der[i]);
    addToPreImage('ffffffff');

  end;
  addToPreImage(inttotx(outputsCount, 2));
  addToPreImage(outputBuffer);
  addToPreImage(inttotx(0, 8));
  Image := preImage;
  result := Image;
end;

end.
